<!DOCTYPE html>
<html lang="en">
	<head>
	<link rel="stylesheet" type="text/css" href="blog.css">
		<meta charset="utf-8">
			<title>Cheatsheet</title>
	</head>
	<body>
		<header>
		<h1>Ruby Cheatsheet</h1>	
		</header>
		<nav>
			<table>
				<tr>
					<td><a href="about_me.html">About Me</a></td>
					<td><a href="week1_cultural.html">Cultural Posts</a></td>
					<td><a href="week1_technical.html">Technical Posts</a></td>
					<td>Cheatsheet</td>
				</tr>
			</table>
		</nav>
		<article>
				<h3>Arrays</h3>
					<p>Ordered, integer-indexed collections of objects.</p>
					<p>Array indexing starts at 0. A negative number is relative to the end of the array, i.e., -1 is the last element, -2 is the second to last element, etc.</p>
					<p>Example:</p>
<pre class="code">
array = ["one", 2.0, 3]  #=>  ["one", 2.0, 3]
</pre>
					<p>Create a new array:</p>
<pre class="code">
array = Array.new  #=>  []
Array.new(4)  #=>  [nil, nil, nil, nil]
</pre>
					<p>Add and remove elements:</p>
<pre class="code">
array = [1, 2, 3]

array.push(4, 5, 6)  #=>  [1, 2, 3, 4, 5, 6]

array.pop  #=>  [1, 2, 3, 4, 5]
</pre>
				<h3>Hashes</h3>
					<p>A collection of key, value pairs similar to an array, except that indexing is controlled via keys of any object type, not an integer index. Hashes enumerate their values according to the associated keys.</p>
					<p>Examples:</p>
<pre class="code">
hash[1, "a", 2, "b"]  #=>  {1=>"a", 2=>"b"}
hash[1 => "a", 2 => "b"]  #=>  {1=>"a", 2=>"b"}
</pre>
				<h3>Strings</h3>
					<p>String objects hold and manipulate a sequence of bytes, generally represented by characters. There are also many different <a href="http://www.ruby-doc.org/core-2.1.2/String.html#method-i-25">built-in</a> <a href="http://www.tutorialspoint.com/ruby/ruby_strings.htm">methods</a> available to modify a string object in Ruby.</p>
<pre class="code">
mystring = String.new("This is my string. There are many like it, but this one is mine.")
</pre>
				<h3>Integers</h3>
					<p>This class encapsulates the two main classes that hold whole numbers in Ruby, Bignum and Fixnum.</p>
					<p><strong>Bignum</strong> objects hold integers outside the range of Fixnum. If an integer calculation would overflow a Fixnum then it is autmatically converted to a <strong>Bignum</strong>. Likewise, if a <strong>Bignum</strong> calculation would result in an integer that fits in a Fixnum, it is automatically converted. <strong>Bignum</strong> values are not immediate, they are referenced. This means that when passing <strong>Bignum</strong> objects as parameters they are working with references to the object, not the object itself.</p>
					<p><strong>Fixnum</strong> objects hold integers that can be represented in a native machine word (minus 1 bit). If a <strong>Fixnum</strong> calculation results in a Bignum return, the value is automatically converted into a Bignum. <strong>Fixnum</strong> objects have immediate value, meaning that when passed as a parameter the actual object itself is used, not a reference to it.</p>
		</article>
	</body>
		<footer>
			<h4>DBC 2014</h4>
		</footer>
</html>